/**	CSIDL_WINDOWS				0x0024		// GetWindowsDirectory()	CSIDL_SYSTEM				0x0025		// GetSystemDirectory()				system32	CSIDL_PROGRAM_FILES			0x0026		// C:\Program Files	CSIDL_SYSTEMX86				0x0029		// x86 system directory on RISC		syswow64	CSIDL_LOCAL_APPDATA			0x001c		// $user name\AppData\Local (non roaming)//설치체크파일정보				[version		, CSIDL		, exeName						, addPath				];var checkFileInfo_1 =		[25138			, 0x0026	, "y85/zv65HGcOkFXjRS2WVg=="	, "TWFya0FueVxtYWVwc3J0"			];var checkFileInfo_2 =		[25138			, 0x0026	, "y85/zv65HGcOkFXjRS2WVg=="	, "TWFya0FueVxtYWVwc3J0"			];var checkFileInfo_3 =		[2507			, 0x0026	, "y85/zv65HGcOkFXjRS2WVg=="	, ""		];var checkFileInfo_4 =		[2507			, 0x0026	, "TWFFUFNCcm9rZXIuZXhl"		, "MDeJJ9yA9U1n9SV3tXQzSXI="		];var checkFileInfo_5 =		[2507			, 0x0026	, "TWFFUFNCcm9rZXIuZXhl"		, "MDeJJ9yA9U1n9SV3tXQzSXI="		];var checkFileInfo_6 =		[2507			, 0x0026	, "TWFFUFNCcm9rZXIuZXhl"		, "MDeJJ9yA9U1n9SV3tXQzSXI="		];var chkFileArray = new Array(checkFileInfo_1);var executeBinaryInfo_1 =	[2507			, 0x0026	, "y85/zv65HGcOkFXjRS2WVg=="	, "TWFya0FueVxtYWVwc3J0"		];var executeBinaryArray = new Array(executeBinaryInfo_1);var checkFileInfo_1 =		[25138			, 0x0026	, "y85/zv65HGcOkFXjRS2WVg=="	, "TWFya0FueVxtYWVwc3J0"			];var chkFileArray = new Array(checkFileInfo_1);*/var maFunType = "";var maCallBackFun;var maResJsonData = new Object();var maOnlyInstallFlag = false;/////////////////////////////////////////////////DEBUG_FUNCTIONfunction addZero(x, n) {	while (x.toString().length < n) { 		x = "0" + x;	}	return x;}/** * 20150930_hcchoi<br> * 스크립트 디버그 메소드<br> * ex) use >>>> debugLog("open End Time", currentTime);<br> * ex) print >>>> ## |15:31:20| checkSocket () :: Start Time = [864] *  * @param valueName *            {String} 변수명 * @param value *            {any} 변수값 * @param caller *            {String} 호출함수명(자동) */function MDBG(valueName, value, caller) {	var callerFun = arguments.callee.caller;	if (caller)		callerFun = callerFun.caller;	var pat = /^function\s+([a-zA-Z0-9_]+)\s*\(/i;	pat.exec(callerFun);	var func = new Object();	func.name = RegExp.$1;	var d = new Date();	var h = addZero(d.getHours(), 2);	var m = addZero(d.getMinutes(), 2);	var s = addZero(d.getSeconds(), 2);	var ms = addZero(d.getMilliseconds(), 3);	var currentTime = h + ":" + m + ":" + s /* + ":" + ms */;	var funNameArr = [];	var maxFunNameLength = 20;	var blankCount = maxFunNameLength - func.name.length;	for (var funnamei = 0; funnamei < func.name.length; funnamei++) {		funNameArr.push(func.name.charAt(funnamei));	}	for (var maxFunName = 0; maxFunName < blankCount; maxFunName++) {		funNameArr.push(' ');	}	var callFunName = funNameArr.join('');	var valueNameArr = [];	var maxValueNameLength = 25;	blankCount = maxValueNameLength - valueName.length;	for (var valuenamei = 0; valuenamei < valueName.length; valuenamei++) {		valueNameArr.push(valueName.charAt(valuenamei));	}	for (var maxValuenamei = 0; maxValuenamei < blankCount; maxValuenamei++) {		valueNameArr.push(' ');	}	var valueName1 = valueNameArr.join('');	//console.log("## |" + currentTime + "| " + callFunName + "() :: " + valueName1 + " = [" + value + "]");	//alert("|" + currentTime + "| " + func.name + "() :: " + valueName + " = [" + value + "]");		var log = document.getElementById("log");	if( log != null)	log.value = log.value + "|" + currentTime + "| " + func.name + "() :: " + valueName + " = [" + value + "]\n";	//document.writeln("## |" + currentTime + "| " + callFunName + "() :: " + valueName1 + " = [" + value + "]<br><\n>"); 	}// //////////////////////////////////////////////////////////////* * hcchoi_20170330 * base64_encode() - base64인코딩 함수 */var MaBase64 = {	// private property	_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", 	// public method for encoding	encode : function (input) {		var output = "";		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;		var i = 0; 		input = MaBase64._utf8_encode(input); 		while (i < input.length) { 			chr1 = input.charCodeAt(i++);			chr2 = input.charCodeAt(i++);			chr3 = input.charCodeAt(i++); 			enc1 = chr1 >> 2;			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);			enc4 = chr3 & 63; 			if (isNaN(chr2)) {				enc3 = enc4 = 64;			} else if (isNaN(chr3)) {				enc4 = 64;			} 			output = output +			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); 		} 		return output;	}, 	// public method for decoding	decode : function (input) {		var output = "";		var chr1, chr2, chr3;		var enc1, enc2, enc3, enc4;		var i = 0; 		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""); 		while (i < input.length) { 			enc1 = this._keyStr.indexOf(input.charAt(i++));			enc2 = this._keyStr.indexOf(input.charAt(i++));			enc3 = this._keyStr.indexOf(input.charAt(i++));			enc4 = this._keyStr.indexOf(input.charAt(i++)); 			chr1 = (enc1 << 2) | (enc2 >> 4);			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);			chr3 = ((enc3 & 3) << 6) | enc4; 			output = output + String.fromCharCode(chr1); 			if (enc3 != 64) {				output = output + String.fromCharCode(chr2);			}			if (enc4 != 64) {				output = output + String.fromCharCode(chr3);			} 		} 		output = MaBase64._utf8_decode(output); 		return output; 	}, 	// private method for UTF-8 encoding	_utf8_encode : function (string) {		string = string.replace(/\r\n/g,"\n");		var utftext = ""; 		for (var n = 0; n < string.length; n++) { 			var c = string.charCodeAt(n); 			if (c < 128) {				utftext += String.fromCharCode(c);			}			else if((c > 127) && (c < 2048)) {				utftext += String.fromCharCode((c >> 6) | 192);				utftext += String.fromCharCode((c & 63) | 128);			}			else {				utftext += String.fromCharCode((c >> 12) | 224);				utftext += String.fromCharCode(((c >> 6) & 63) | 128);				utftext += String.fromCharCode((c & 63) | 128);			} 		} 		return utftext;	}, 	// private method for UTF-8 decoding	_utf8_decode : function (utftext) {		var string = "";		var i = 0;		var c = c1 = c2 = 0; 		while ( i < utftext.length ) { 			c = utftext.charCodeAt(i); 			if (c < 128) {				string += String.fromCharCode(c);				i++;			}			else if((c > 191) && (c < 224)) {				c2 = utftext.charCodeAt(i+1); 				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));				i += 2;			}			else {				c2 = utftext.charCodeAt(i+1);				c3 = utftext.charCodeAt(i+2);				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));				i += 3;			} 		} 		return string;	} }/** * hcchoi_20170411 * Init함수. 콜백함수 및 명령어 세팅 후 브로커 호출 * @param maEPS_InstallCheck - 리턴해줄 콜백 함수. 전역변수 maResJsonData에 최종 결과 JSON 데이터를 받을 수 있습니다. * @returns */function maBrokerInit(callbackFun, commandType){	maFunType = commandType;	maCallBackFun = callbackFun;		if( commandType == "getVersion"){		var chkFileCommand = craeteBoekerCommand(chkFileArray);			}else if( commandType == "executeBinary"){		var chkFileCommand = craeteBoekerCommand(executeBinaryArray);	}	maBroker(chkFileCommand);	return;}/** * hcchoi_20170411 * URI 세팅. 파라미터 설정 후 브로커 호출 함수 * 브로커 회신 데이터는 maBrokerController()에 전달하여 처리하며 최종 결과값 maResJsonData 을 콜백함수에 리턴 * @param bokerCommand * @returns */function maBroker(bokerCommand){	//setBrokerURI	var brokerServerURI = getBrokerServerURI();	var d = new Date();	var h = addZero(d.getHours(), 2);	var m = addZero(d.getMinutes(), 2);	var s = addZero(d.getSeconds(), 2);	var ms = addZero(d.getMilliseconds(), 3);	var currentTime = h + "" + m + "" + s + "" + ms ;	var brokerParam = "[MAEPS]" + MaBase64.encode(bokerCommand)+ "[MAEPSEOF]" + currentTime;		// 버전 체크용	var brokerServerURL = brokerServerURI + "/?brokerCommand=" + brokerParam;	MDBG("brokerServerURL", brokerServerURL );	//call broker	//제이쿼리 1.5이하 .done 없음	$.getJSON(brokerServerURL, {		dataType:"json",		contentType:"application/json; charset=UTF-8"	}) 		//Event Method	.done(function(data, status, err) {		maBrokerController(data, status, err);  		maCallBackFun(maResJsonData);	})	.fail(function(data, status, err) {		var maErrString = "";		//TODO 미동작, 에러케이스에 따라 상세 확인 필요		MDBG("status", status.toString() );		MDBG("data", JSON.stringify(data) );		MDBG("err", err.toString() );		if( err.toString() == "" || (err.toString() == "error" && data.status == 500) ){			maResJsonData = maSetBrokerErr(-9000);		}else{			maResJsonData = err.toString() + " <br> " + data.responseText;		}		maCallBackFun(maResJsonData);	})	.always(function(data, status, err) {			});}/* * hcchoi_20170330<Br> * http / https 프로토콜에 따른 호출 URI 설정 함수 */function getBrokerServerURI(){	var maurl;	if(window.location.protocol === 'https:') 		maurl = "https://127.0.0.1:19876";	else		maurl = "http://127.0.0.1:19875";		return maurl;}/** * 20170410_hcchoi<br> * 선언되어있는 파일버전과 비교화여 설치여부를 추가로 JSON데이터의 installFag값에 추가하는 함수.<br> * installFlag :: true - 최신버전 // false - 미설치, 업데이트 필요 *  * @param checkFileRetJsonData - 브로커로부터 리턴받은 파일정보 JSON * @returns JsonData<br>	 * 			ex){ "fileName" : "broker.exe", "fileVersion" : "2510", "installFlag" : "true"}  */function maSetFileInstallFlag(checkFileRetJsonData){	var fileVersionJsonData = checkFileRetJsonData["fileVerRet"];		for(var chkFile_i=0; chkFile_i < chkFileArray.length; chkFile_i++){			var fileName = fileVersionJsonData[chkFile_i].name;		var fileVersion = fileVersionJsonData[chkFile_i].version		var defineVersion = chkFileArray[chkFile_i][0];				if( fileVersion - defineVersion >= 0 ){			fileVersionJsonData[chkFile_i].installFlag = true;		}else{			fileVersionJsonData[chkFile_i].installFlag = false;		}		MDBG(chkFile_i + "_" + fileName , "defineVersion = " + defineVersion + " || installVersion = " + fileVersion + " || installFlag = " + fileVersionJsonData[chkFile_i].installFlag);	}	return 	fileVersionJsonData;}/** *  hcchoi_20170411<Br> * 선언한 체크파일 정보를 기반으로 브로커에 보낼 명령어를 JSON형태로 만드는 함수. * @param chkFileArray		- 설치체크 파일 정보 배열 * @returns				- JSON형태의 broker 명령어 */function craeteBoekerCommand(brokerParam){	var brokerReqJsonData = new Object(); 	brokerReqJsonData.funType = maFunType;		if( maFunType == "getVersion" ){		brokerReqJsonData.chkFileInfo = new Array();		for(var obj_i=0; obj_i < brokerParam.length; obj_i++){			var checkFile = new Object();			checkFile.csidl = brokerParam[obj_i][1];			checkFile.name = brokerParam[obj_i][2];			checkFile.addPath = brokerParam[obj_i][3];						brokerReqJsonData.chkFileInfo[obj_i] = checkFile;		}	}else if( maFunType == "executeBinary" ){		brokerReqJsonData.executeBinaryInfo = new Array();		for(var obj_i=0; obj_i < brokerParam.length; obj_i++){			var executeBinary = new Object();			executeBinary.parameter = brokerParam[obj_i][0];			executeBinary.csidl = brokerParam[obj_i][1];			executeBinary.name = brokerParam[obj_i][2];			executeBinary.addPath = brokerParam[obj_i][3];						brokerReqJsonData.executeBinaryInfo[obj_i] = executeBinary;		}	}			MDBG("json_BrokerComand", JSON.stringify(brokerReqJsonData) );	return JSON.stringify(brokerReqJsonData);}/** * hcchoi_20170411 * broker의 회신을 기반으로 데이터 처리 * @returns */function maBrokerController(data, status, err){	var responseStatus = status.toString();		MDBG("status", responseStatus );	MDBG("data", JSON.stringify(data) );	MDBG("err", err.toString() );		//broker에러코드 리턴	if( typeof(data) == "number" ){		maResJsonData = maSetBrokerErr(data);		return;		//비정상 통신	}else if(data == null){		maResJsonData = maSetBrokerErr(0);		return;	}		if( maFunType == "getVersion" ){		maResJsonData = maSetFileInstallFlag(data);		maGetOnlyInstallFlag();	}else if( maFunType == "executeBinary" ){		maResJsonData = data;	}	return;}/** * hcchoi_20160414 * 에러코드에 따른 에러 리턴 함수 */function maSetBrokerErr(err){		var strError ;	switch ( err ){		case -2001:			strError = "요청 데이터가 없습니다.";			break;		case -2002:			strError = "시그니처를 찾을 수 없습니다.";			break;					case -2003:			strError = "명령어 형태가 올바르지 않습니다.";			break;		case -9000:			strError = "MaEPSBroker.exe 모듈의 설치 혹은 업데이트가 필요합니다.";			break;					case 0:			strError = "버전 체크 중 오류가 발생 하였습니다.";			break;				//broker하위버전 호환		case 99999:			strError = "요청 데이터가 올바르지 않습니다.";			break;		default:			//하위버전의 호환을 위해서추가 - 파라미터가 이상할 경우 기본적으로 ePageSafer.exe를 찾아 오는 듯..			//하위버전에서 ePageSafer.exe를 찾아왔거나 미 설치로 25000를 리턴 받았을 경우			if( err - 30000 < 0 ){				strError = "MaEPSBroker.exe 모듈의 설치 혹은 업데이트가 필요합니다.";			}else{				strError = "버전 체크 중 오류가 발생 하였습니다."			}			break;	}	return strError;}/** * hcchoi_20170415 * 전역변수 maOnlyInstallFlag에 설치 필요 유무설정하는 함수 */function maGetOnlyInstallFlag(){	for(var chkFile_i=0; chkFile_i < maResJsonData.length; chkFile_i++){		var chkFileInstallFlag = maResJsonData[chkFile_i].installFlag;				if( chkFileInstallFlag == false ){			maOnlyInstallFlag = false;			break;		}else{			maOnlyInstallFlag = true;		}	}	MDBG("maOnlyInstallFlag", maOnlyInstallFlag);}